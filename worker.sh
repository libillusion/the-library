#!/bin/bash
# Illusion worker file. DO NOT MODIFY
# Autogenerated by libworker (Illusion) on Fri Oct 31 06:36:47 PM +07 2025
source "/media/heavy/Projects/NDM/9/projects/illusion/includes/libijson.sh"
source "/media/heavy/Projects/NDM/9/projects/illusion/includes/libdeluluclient.sh"
source "/media/heavy/Projects/NDM/9/projects/illusion/main.sh"
DELULU_AUTHKEY="RBeScV4vC6uO2dRLNwR1MlqBI4wwnR43uvtMncO7lP1MJ2fvHscnSUed5mzOiHV5"
DELULU_SOCKET="/tmp/tmp.db9a849a_c477_486b_98ce_13e659d0da2f"
# MODULE START
declare -A WORKER_HTTP_STATUS_CODE=([429]="429 Too Many Requests" [403]="403 Forbidden" [402]="402 Payment Required" [401]="401 Unauthorized" [400]="400 Bad Request" [406]="406 Not Acceptable" [405]="405 Method Not Allowed" [404]="404 Not Found" [409]="409 Conflict" [408]="408 Request Timeout" [451]="451 Unavailable For Legal Reasons" [205]="205 Reset Content" [204]="204 No Content" [206]="206 Partial Content" [201]="201 Created" [200]="200 OK" [203]="203 Non-Authoritative Information" [431]="431 Request Header Fields Too Large" [202]="202 Accepted" [103]="103 Early Hints" [100]="100 Continue" [101]="101 Switching Protocols" [308]="308 Permanent Redirect" [304]="304 Not Modified" [307]="307 Temporary Redirect" [300]="300 Multiple Choices" [301]="301 Moved Permanently" [302]="302 Found" [303]="303 See Other" [502]="502 Bad Gateway" [503]="503 Service Unavailable" [500]="500 Internal Server Error" [501]="501 Not Implemented" [504]="504 Gateway Timeout" [505]="505 HTTP Version Not Supported" [410]="410 Gone" [413]="413 Payload Too Large" [414]="414 URI Too Long" [415]="415 Unsupported Media Type" )
declare -A WORKER_STATIC_ROUTES_GET=([/file.py]="disposition_test" [/]="index" )
declare -A WORKER_DYNAMIC_ROUTES_GET=(["/users/([^/]+)/posts/([^/]+)/?"]="index <=> user_id post_id" )
declare -A WORKER_STATIC_ROUTES_POST=([/]="test_post" )
declare -A WORKER_DYNAMIC_ROUTES_POST
declare -A WORKER_STATIC_ROUTES_PATCH
declare -A WORKER_DYNAMIC_ROUTES_PATCH
declare -A WORKER_STATIC_ROUTES_PUT
declare -A WORKER_DYNAMIC_ROUTES_PUT
declare -A WORKER_STATIC_ROUTES_DELETE
declare -A WORKER_DYNAMIC_ROUTES_DELETE
declare -a WORKER_HANDLE_CALL_HOOKS=([0]="example.worker.hooks.handle_call" [1]="worker.hooks.handle_call")
declare -a WORKER_HANDLE_RESPONSE_HOOKS=([0]="example.worker.hooks.handle_response" [1]="worker.hooks.handle_response")
uuidgen () 
{ 
    cat /proc/sys/kernel/random/uuid | sed 's+-+_+g'
}
lower () 
{ 
    printf '%s\n' "${1,,}"
}
urldecode () 
{ 
    local url_encoded="${1//+/ }";
    printf '%b\n' "${url_encoded//%/\\x}"
}
worker.parse_get_data () 
{ 
    local entry;
    IFS='?' read -r REQ_PATH get <<< "$REQ_PATH_RAW";
    REQ_PATH="/${REQ_PATH#/}";
    get="$(urldecode "$get")";
    IFS='#' read -r REQ_PATH _ <<< "$REQ_PATH";
    REQ_QUERY_STRING="$get";
    IFS='&' read -ra data <<< "$get";
    for entry in "${data[@]}";
    do
        IFS="=" read -r key val <<< "$entry";
        REQ_QUERIES["$key"]="$val";
    done
}
req.session.set () 
{ 
    [ -z "$2" ] && return 1;
    delulu.request SET "session_${REQ_SESSION_ID}_${1}" "${2}"
}
req.session.get () 
{ 
    [ -z "$1" ] && return 1;
    local DATA="${REQ_SESSION_DB["${1}"]}";
    [[ -z "$DATA" ]] && return 1;
    echo "$DATA"
}
req.session.get_to () 
{ 
    [ -z "$2" ] && return 1;
    local -n _output="$1";
    delulu.request GET "session_${REQ_SESSION_ID}_${2}";
    _output="$_DELULU_RESPONSE"
}
req.data.get () 
{ 
    REQ_POST_DATA.get $@
}
req.data.get_to () 
{ 
    REQ_POST_DATA.get_to $@
}
req.query.get () 
{ 
    [[ -n "$1" ]] && printf '%s\n' "${REQ_QUERIES["$1"]}"
}
req.query.get_to () 
{ 
    [[ -n "$2" ]] && "$2"="${REQ_QUERIES["$1"]}"
}
req.response.get () 
{ 
    cat /proc/self/fd/299
}
req.response._openfd () 
{ 
    local OUT_PATH="$(mktemp)";
    exec 295<> "$OUT_PATH";
    rm "$OUT_PATH";
    REQ_BUILT_RESPONSE=true
}
req.response.set.from_text () 
{ 
    printf "%s" "$@" > /proc/self/fd/299
}
req.response.set.from_args () 
{ 
    printf "%s" "$@" > /proc/self/fd/299
}
req.response.set.from_pipe () 
{ 
    req.response._openfd;
    cat > /proc/self/fd/295;
    cat /proc/self/fd/295 > /proc/self/fd/299;
    exec 295>&-
}
req.response.set.from_variable () 
{ 
    local -n _input="$1";
    printf '%s\n' "$_input" > /proc/self/fd/299
}
req.response.set.from_stdin () 
{ 
    req.response._openfd;
    cat > /proc/self/fd/295;
    cat /proc/self/fd/295 > /proc/self/fd/299;
    exec 295>&-
}
worker.parse_http_headers () 
{ 
    local line _h _v;
    while read -r line; do
        line="${line%%''}";
        [[ -z "$line" ]] && return;
        _h="${line%%:*}";
        REQ_HEADERS["${_h,,}"]="${line#*: }";
    done
}
worker.parse_cookies_data () 
{ 
    local -a cookie;
    local entry key value;
    IFS=';' read -ra cookie <<< "${REQ_HEADERS["cookie"]}";
    for entry in "${cookie[@]}";
    do
        IFS='=' read -r key value <<< "$entry";
        REQ_COOKIES["${key# }"]="${value% }";
    done
}
worker.parse_data () 
{ 
    local entry;
    local content_type="${REQ_HEADERS["content-type"]}";
    if [[ "$content_type" == "application/x-www-form-urlencoded" ]]; then
        IFS='&' read -rN "${REQ_HEADERS["content-length"]}" -a data;
        for entry in "${data[@]}";
        do
            entry="${entry%%''}";
            REQ_POST_DATA["${entry%%=*}"]="${entry#*:}";
        done;
    else
        if [[ "$content_type" == "application/json" ]]; then
            read -rN "${REQ_HEADERS["content-length"]}" data;
            REQ_POST_DATA="${data%%''}";
            ijson_parse_to REQ_POST_DATA <<< "$REQ_POST_DATA";
        else
            read -rN "${REQ_HEADERS["content-length"]}" data;
            REQ_POST_DATA="${data%%''}";
        fi;
    fi
}
worker.build_response_headers () 
{ 
    printf 'HTTP/1.1 %s\r\n' "${REQ_RESPONSE_HEADERS['status']}";
    unset 'REQ_RESPONSE_HEADERS["status"]';
    if [[ "${#REQ_COOKIE_TO_SEND[@]}" -gt "0" ]]; then
        for key in "${!REQ_COOKIE_TO_SEND[@]}";
        do
            printf 'Set-Cookie: %s=%s;\r\n' "${key}" "${REQ_COOKIE_TO_SEND["${key}"]}";
        done;
    fi;
    for key in "${!REQ_RESPONSE_HEADERS[@]}";
    do
        printf '%s: %s\r\n' "${key,,}" "${REQ_RESPONSE_HEADERS[$key]}";
    done;
    printf '\r\n'
}
worker.build_response () 
{ 
    REQ_BUILT_RESPONSE=true;
    for _fn in "${WORKER_HANDLE_RESPONSE_HOOKS[@]}";
    do
        "$_fn" 1>&299;
    done;
    local REQ_RESPONSE_CODE="${1:-200}";
    REQ_RESPONSE_HEADERS['status']="${WORKER_HTTP_STATUS_CODE[${REQ_RESPONSE_CODE}]}";
    REQ_RESPONSE_HEADERS["content-length"]=$(wc -c /proc/self/fd/299 | awk '{print $1}');
    [[ -z "${REQ_RESPONSE_HEADERS["content-type"]}" ]] && REQ_RESPONSE_HEADERS["content-type"]=$(file -L --mime-type -b /proc/self/fd/299);
    worker.build_response_headers;
    cat /proc/self/fd/299 2> /dev/null
}
worker.build_error_response () 
{ 
    local ERROR_CODE=${1:-500};
    local HTTP_STATUS=${WORKER_HTTP_STATUS_CODE["$ERROR_CODE"]};
    if [ ! -v "WORKER_ERROR_HTML" ]; then
        printf "<!DOCTYPE html><head><title>${HTTP_STATUS}</title></header><body style=\"background: #090909; color: #FFF; font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh;\"><center><h1 style=\"color: oklch(0.577 0.207 20deg);\">${HTTP_STATUS}</h1><hr><p style=\"color: oklch(0.97 0 0);\">Illusion Web Server</p></center></body>";
    fi;
    @respond "$ERROR_CODE"
}
worker.build_error_response.404 () 
{ 
    worker.build_error_response 404
}
worker.build_error_response.405 () 
{ 
    worker.build_error_response 405
}
worker.process_request_data () 
{ 
    local REQ_METHOD REQ_PATH REQ_PATH_RAW REQ_HTTP_VERSION REQ_QUERY_STRING REQ_PEERADDR;
    local -A REQ_HEADERS;
    local -A REQ_POST_DATA;
    local -A REQ_QUERIES;
    local -A REQ_RESPONSE_HEADERS;
    local -A REQ_COOKIES;
    local -A REQ_SESSION;
    local -A REQ_COOKIE_TO_SEND;
    read -r REQ_METHOD REQ_PATH_RAW REQ_HTTP_VERSION;
    REQ_HTTP_VERSION="${REQ_HTTP_VERSION%%''}";
    REQ_PEERADDR=${SOCAT_PEERADDR:-undefined};
    local -A REQ_PATH_PROC;
    REQ_PATH="$(printf '%s' "${REQ_PATH_RAW%%\?*}")";
    worker.parse_http_headers;
    worker.parse_get_data;
    worker.parse_cookies_data;
    if [[ "${REQ_COOKIES["X-Illusion-Session"]}" == "" ]]; then
        REQ_SESSION_ID="$(uuidgen)";
    else
        REQ_SESSION_ID="${REQ_COOKIES["X-Illusion-Session"]}";
    fi;
    REQ_COOKIE_TO_SEND["X-Illusion-Session"]="$REQ_SESSION_ID";
    if ( [[ "$REQ_METHOD" == "POST" ]] || [[ "$REQ_METHOD" == "PUT" ]] || [[ "$REQ_METHOD" == "PATCH" ]] ) && [[ "${REQ_HEADERS['content-length']}" -gt "0" ]]; then
        worker.parse_data;
    fi;
    REQ_OUT_PATH="$(mktemp)";
    exec 299<> "$REQ_OUT_PATH";
    rm "$REQ_OUT_PATH";
    worker.process_path
}
worker.cleanup_request () 
{ 
    exec 299>&-;
    exec 296>&-
}
worker.process_path () 
{ 
    local -n WORKER_STATIC_ROUTES="WORKER_STATIC_ROUTES_${REQ_METHOD}";
    local -n WORKER_DYNAMIC_ROUTES="WORKER_DYNAMIC_ROUTES_${REQ_METHOD}";
    if [[ "${WORKER_STATIC_ROUTES@a}" != "A" ]] || [[ "${WORKER_DYNAMIC_ROUTES@a}" != "A" ]]; then
        worker.handle_call "worker.build_error_response.405";
        return;
    fi;
    local REQ_FUNCTION="${WORKER_STATIC_ROUTES["${REQ_PATH}"]}";
    local fn field;
    if [[ -z "$REQ_FUNCTION" ]]; then
        for _re in "${!WORKER_DYNAMIC_ROUTES[@]}";
        do
            if [[ "$REQ_PATH" =~ ^${_re}$ ]]; then
                IFS=" <=> " read -r fn fields <<< "${WORKER_DYNAMIC_ROUTES["${_re}"]}";
                local i=1;
                for field in ${fields#"=> "};
                do
                    export "$field"="${BASH_REMATCH[${i}]}";
                    i=$(($i + 1));
                done;
                unset i;
                worker.handle_call "$fn";
                return;
            fi;
        done;
        worker.handle_call "worker.build_error_response.404";
    else
        worker.handle_call "$REQ_FUNCTION";
        return;
    fi
}
worker.handle_call () 
{ 
    declare -g REQ_BUILT_RESPONSE=false;
    local REQ_FUNCTION="$1";
    if [[ "${#WORKER_HANDLE_CALL_HOOKS[@]}" -gt 0 ]]; then
        for _fn in "${WORKER_HANDLE_CALL_HOOKS[@]}";
        do
            "$_fn" 1>&299;
            if "$REQ_BUILT_RESPONSE"; then
                cat /proc/self/fd/296;
                return;
            fi;
        done;
        "$REQ_FUNCTION" 1>&299;
    else
        "$REQ_FUNCTION" 1>&299;
    fi;
    if ! "$REQ_BUILT_RESPONSE"; then
        worker.build_response 200;
    else
        cat /proc/self/fd/296;
    fi
}
worker.hooks.handle_call () 
{ 
    @log "$REQ_PEERADDR | $REQ_METHOD $REQ_PATH $REQ_FUNCTION"
}
worker.hooks.handle_response () 
{ 
    @set_cookie "X-Something-IThink" "lool123"
}
example.worker.hooks.handle_call () 
{ 
    echo "Fuck you."
}
example.worker.hooks.handle_response () 
{ 
    echo hi
}
trap worker.cleanup_request EXIT;
worker.process_request_data
# MODULE END
